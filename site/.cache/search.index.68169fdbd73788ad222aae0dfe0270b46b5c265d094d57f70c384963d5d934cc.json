"{\"value\":{\"mdx\":\"# Frequently Asked Questions\\n\\nFrequently asked questions related to viem.\\n\\n**TL;DR: viem tries to avoid creating unnecessary abstractions on top of existing systems.**\\n\\nFeel free to add to this document if you notice frequently asked questions that are not covered here.\\n\\n{/* [[toc]] */}\\n\\n## Why use the terms \\\"Wallet\\\" & \\\"Account\\\" instead of \\\"Signer\\\"\\n\\nviem attempts to align to the \\\"Wallet\\\" and \\\"Account\\\" [terminology on Ethereum.org](https://ethereum.org/en/glossary/). The term \\\"Signer\\\" was adapted from ethers.js.\\n\\nLet's clear up on some terms before we dive in.\\n\\n- Wallet: An application or interface that holds Account(s).\\n- Account: An object that represents an address, balance, nonce, and optional storage and code.\\n- Private Key: Proves ownership of an Account, and can sign messages & transactions.\\n\\nIn the context of viem, a Wallet Client is an interface that can hold an Account. The Account may or may not hold a Private Key.\\n\\nIn viem, there are two types of Accounts:\\n- Local Account: can **synchronously & directly** sign messages and transactions using its Private Key. A signature is guaranteed.\\n- JSON-RPC Account: **asynchronously requests** signing of messages and transactions from the target Wallet over JSON-RPC (e.g. Browser Extension or WalletConnect). The target Wallet holds the Account & Private Key. A signature is not guaranteed (the target Wallet may not have permitted the Account, or the Wallet may have rejected the request).\\n\\nWe do not use the term \\\"Signer\\\" because there are noticeable behavioral differences between signing locally and signing over JSON-RPC.\\n\\n## Why are contract function `args` with fully-named inputs represented as unnamed tuple types instead of object types?\\n\\nLet's look at an example! Suppose I have the following function in my contract:\\n\\n```solidity\\nfunction transferFrom(address sender, address recipient, uint256 amount) returns (bool)\\n```\\n\\nAll the inputs are named (`sender`, `recipient`, and `amount`) so I might be tempted to represent the parameters as the following TypeScript type:\\n\\n```ts\\ntype Args = {\\n  sender: `0x${string}`;\\n  recipient: `0x${string}`;\\n  amount: bigint;\\n}\\n```\\n\\nThis improves developer experience a bit because now I can see the names of the parameters in my editor.\\n\\n```ts\\nimport { createWalletClient, parseAbi } from 'viem'\\n\\nconst client = createWalletClient(…)\\nclient.writeContract({\\n  address: '0x…',\\n  abi: parseAbi([\\n    'function transferFrom(address sender, address recipient, uint256 amount) returns (bool)',\\n  ]),\\n  functionName: 'transferFrom',\\n  args: {\\n    sender: '0x…',\\n    recipient: '0x…',\\n    amount: 100n,\\n  },\\n})\\n```\\n\\nHowever, this only works if all the inputs are named (some compilers will strip names from inputs). If any of the inputs are unnamed, then you'll have to use a tuple instead:\\n\\n```ts\\nclient.writeContract({\\n  address: '0x…',\\n  abi: parseAbi([\\n    'function transferFrom(address, address, uint256) returns (bool)',\\n  ]),\\n  functionName: 'transferFrom',\\n  args: ['0x…', '0x…', 100n],\\n})\\n```\\n\\nThis can get even more complicated when a function has overloads:\\n\\n```solidity\\nfunction safeTransferFrom(address, address, uint256) {}\\nfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes data) {}\\n```\\n\\nIn this case, the type of the overload parameters start to diverge from each other:\\n\\n```ts\\ntype Args =\\n  | [`0x${string}`, `0x${string}`, bigint]\\n  | {\\n      from: `0x${string}`;\\n      to: `0x${string}`;\\n      tokenId: bigint;\\n      data: string;\\n    }\\n```\\n\\nIf you want to switch between the two overloads in your code, you'll need to completely change the type instead of just adding or removing a single positional argument from the end. (Objects also don't enforce type-level ordering so you can put them in whatever order you want. This would also mean that viem would also need to internally validate order during runtime, adding some extra overhead.)\\n\\n```diff\\nclient.writeContract({\\n  address: '0x…',\\n  abi: parseAbi([\\n    'function safeTransferFrom(address, address, uint256)',\\n    'function safeTransferFrom(address from, address to, uint256 tokenId, bytes data)',\\n  ]),\\n  functionName: 'safeTransferFrom',\\n- args: ['0x…', '0x…', 100n],\\n+ args: {\\n+   from: '0x…',\\n+   to: '0x…',\\n+   tokenId: 100n,\\n+   data: '0x…',\\n+ },\\n})\\n```\\n\\nEven though overloads are an edge case, it would be sufficiently [astonishing](https://en.wikipedia.org/wiki/Principle_of_least_astonishment) to come across this behavior. So what's the best way to represent `args`? Well, they are positional at the contract-level so it makes sense to represent them that way in viem too.\\n\\nNot all is lost when it comes to developer experience though! Tuple types in TypeScript can have [names](https://www.typescriptlang.org/play?ts=4.0.2#example/named-tuples) attached to them:\\n\\n```ts\\ntype Args = [from: `0x${string}`, to: `0x${string}`, tokenId: bigint]\\n```\\n\\nThese names show up in your editor so you get nice developer experience when using autocomplete, etc. Unfortunately, TypeScript doesn't support dynamic named tuples right now, but we are watching [this issue](https://github.com/microsoft/TypeScript/issues/44939) closely and once it is implemented, we will add it to viem. In the meantime, hang tight!\\n\\n## Why is a contract function return type returning an array instead of an object?\\n\\nSuppose your ABI looks like this:\\n\\n```ts\\n[\\n  {\\n    inputs: [],\\n    name: \\\"latestRoundData\\\",\\n    outputs: [\\n      { name: \\\"roundId\\\", type: \\\"uint80\\\" },\\n      { name: \\\"answer\\\", type: \\\"int256\\\" },\\n      { name: \\\"startedAt\\\", type: \\\"uint256\\\" },\\n      { name: \\\"updatedAt\\\", type: \\\"uint256\\\" },\\n      { name: \\\"answeredInRound\\\", type: \\\"uint80\\\" },\\n    ],\\n    stateMutability: \\\"view\\\",\\n    type: \\\"function\\\",\\n  }\\n]\\n```\\n\\nYou might be confused why the following does not return an object:\\n\\n```ts\\nimport { createPublicClient, parseAbi } from 'viem'\\n\\nconst client = createPublicClient(…)\\nconst res = await client.readContract({\\n  address: '0x…',\\n  abi: […], // abi from above\\n  functionName: 'latestRoundData',\\n})\\nres\\n// ^? const res: [bigint, bigint, bigint, bigint, bigint]\\n```\\n\\nThis is expected. `\\\"latestRoundData\\\"` `outputs` is an array of types, so you get an array of decoded values as the return type. viem only maps explicitly typed tuples as objects\\n\\nWhy does viem follow this approach? Here is the contract function definition for `latestRoundData` with two different return types:\\n\\n```solidity\\nfunction latestRoundData() external view\\n  returns (\\n    uint80 roundId,\\n    int256 answer,\\n    uint256 startedAt,\\n    uint256 updatedAt,\\n    uint80 answeredInRound\\n  );\\n\\nstruct Data {\\n  uint80 roundId;\\n  uint256 answer;\\n  uint256 startedAt;\\n  uint256 updatedAt;\\n  uint80 answeredInRound\\n}\\n\\nfunction latestRoundData() external view returns (Data data);\\n```\\n\\nThe first function returns a set of five items, so viem maps it to an array. The reason why we don't convert it to an object is because things get ambiguous when we come to decode structs. How do you determine the difference between a \\\"return\\\" tuple (first function) and a \\\"struct\\\" tuple (second function).\\n\\nAnother reason is that folks might expect it to be an array (because it is a set of return items). Other libraries, like ethers, mitigate this by returning a hybrid Array/Object type, but that kind of type is not serializable in JavaScript, and viem prefers to not try and \\\"hack\\\" JavaScript types.\\n\\n## Why doesn't Wallet Client support public actions?\\n\\nWallet Client doesn't support public actions because wallet providers (Injected `window.ethereum`, WalletConnect v2, etc.) may not provide a large majority of \\\"node\\\"/\\\"public\\\" RPC methods like `eth_call`, `eth_newFilter`, `eth_getLogs`, etc. This is because these methods are not required for a wallet provider to function properly. For example, a wallet provider may only support `eth_sendTransaction` and `eth_sign` and nothing else.\\n\",\"document\":[{\"href\":\"/docs/faq#frequently-asked-questions\",\"html\":\"</header>\\n<p>Frequently asked questions related to viem.</p>\\n<strong>TL;DR: viem tries to avoid creating unnecessary abstractions on top of existing systems.</strong>\\n<p>Feel free to add to this document if you notice frequently asked questions that are not covered here.</p>\\n\\n\",\"id\":\"pages/docs/faq.mdx#frequently-asked-questions\",\"isPage\":true,\"text\":\"\\nFrequently asked questions related to viem.\\nTL;DR: viem tries to avoid creating unnecessary abstractions on top of existing systems.\\nFeel free to add to this document if you notice frequently asked questions that are not covered here.\\n\\n\",\"title\":\"Frequently Asked Questions\",\"titles\":[]},{\"href\":\"/docs/faq#why-use-the-terms-wallet--account-instead-of-signer\",\"html\":\"\\n<p>viem attempts to align to the &quot;Wallet&quot; and &quot;Account&quot; <a href=\\\"https://ethereum.org/en/glossary/\\\">terminology on Ethereum.org</a>. The term &quot;Signer&quot; was adapted from ethers.js.</p>\\n<p>Let&#x27;s clear up on some terms before we dive in.</p>\\n<ul>\\n<li>Wallet: An application or interface that holds Account(s).</li>\\n<li>Account: An object that represents an address, balance, nonce, and optional storage and code.</li>\\n<li>Private Key: Proves ownership of an Account, and can sign messages &amp; transactions.</li>\\n</ul>\\n<p>In the context of viem, a Wallet Client is an interface that can hold an Account. The Account may or may not hold a Private Key.</p>\\n<p>In viem, there are two types of Accounts:</p>\\n<ul>\\n<li>Local Account: can <strong>synchronously &amp; directly</strong> sign messages and transactions using its Private Key. A signature is guaranteed.</li>\\n<li>JSON-RPC Account: <strong>asynchronously requests</strong> signing of messages and transactions from the target Wallet over JSON-RPC (e.g. Browser Extension or WalletConnect). The target Wallet holds the Account &amp; Private Key. A signature is not guaranteed (the target Wallet may not have permitted the Account, or the Wallet may have rejected the request).</li>\\n</ul>\\n<p>We do not use the term &quot;Signer&quot; because there are noticeable behavioral differences between signing locally and signing over JSON-RPC.</p>\\n\",\"id\":\"pages/docs/faq.mdx#why-use-the-terms-wallet--account-instead-of-signer\",\"isPage\":false,\"text\":\"\\nviem attempts to align to the &quot;Wallet&quot; and &quot;Account&quot; terminology on Ethereum.org. The term &quot;Signer&quot; was adapted from ethers.js.\\nLet&#x27;s clear up on some terms before we dive in.\\n\\nWallet: An application or interface that holds Account(s).\\nAccount: An object that represents an address, balance, nonce, and optional storage and code.\\nPrivate Key: Proves ownership of an Account, and can sign messages &amp; transactions.\\n\\nIn the context of viem, a Wallet Client is an interface that can hold an Account. The Account may or may not hold a Private Key.\\nIn viem, there are two types of Accounts:\\n\\nLocal Account: can synchronously &amp; directly sign messages and transactions using its Private Key. A signature is guaranteed.\\nJSON-RPC Account: asynchronously requests signing of messages and transactions from the target Wallet over JSON-RPC (e.g. Browser Extension or WalletConnect). The target Wallet holds the Account &amp; Private Key. A signature is not guaranteed (the target Wallet may not have permitted the Account, or the Wallet may have rejected the request).\\n\\nWe do not use the term &quot;Signer&quot; because there are noticeable behavioral differences between signing locally and signing over JSON-RPC.\\n\",\"title\":\"Why use the terms &quot;Wallet&quot; &amp; &quot;Account&quot; instead of &quot;Signer&quot;\",\"titles\":[\"Frequently Asked Questions\"]},{\"href\":\"/docs/faq#why-are-contract-function-args-with-fully-named-inputs-represented-as-unnamed-tuple-types-instead-of-object-types\",\"html\":\"\\n<p>Let&#x27;s look at an example! Suppose I have the following function in my contract:</p>\\n<pre class=\\\"shiki shiki-themes github-light github-dark-dimmed\\\" style=\\\"background-color:#fff;--shiki-dark-bg:#22272e;color:#24292e;--shiki-dark:#adbac7\\\" tabindex=\\\"0\\\"><code><span class=\\\"line\\\"><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">function</span><span style=\\\"color:#6F42C1;--shiki-dark:#DCBDFB\\\"> transferFrom</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">(</span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">address</span><span style=\\\"color:#E36209;--shiki-dark:#F69D50\\\"> sender</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">, </span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">address</span><span style=\\\"color:#E36209;--shiki-dark:#F69D50\\\"> recipient</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">, </span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">uint256</span><span style=\\\"color:#E36209;--shiki-dark:#F69D50\\\"> amount</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">) </span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">returns</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\"> (</span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">bool</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">)</span></span></code></pre>\\n<p>All the inputs are named (<code>sender</code>, <code>recipient</code>, and <code>amount</code>) so I might be tempted to represent the parameters as the following TypeScript type:</p>\\n<pre class=\\\"shiki shiki-themes github-light github-dark-dimmed\\\" style=\\\"background-color:#fff;--shiki-dark-bg:#22272e;color:#24292e;--shiki-dark:#adbac7\\\" tabindex=\\\"0\\\"><code><span class=\\\"line\\\"><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">type</span><span style=\\\"color:#6F42C1;--shiki-dark:#F69D50\\\"> Args</span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\"> =</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\"> {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#E36209;--shiki-dark:#F69D50\\\">  sender</span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">:</span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\"> `0x${</span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">string</span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">}`</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#E36209;--shiki-dark:#F69D50\\\">  recipient</span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">:</span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\"> `0x${</span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">string</span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">}`</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#E36209;--shiki-dark:#F69D50\\\">  amount</span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">:</span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\"> bigint</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">}</span></span></code></pre>\\n<p>This improves developer experience a bit because now I can see the names of the parameters in my editor.</p>\\n<pre class=\\\"shiki shiki-themes github-light github-dark-dimmed\\\" style=\\\"background-color:#fff;--shiki-dark-bg:#22272e;color:#24292e;--shiki-dark:#adbac7\\\" tabindex=\\\"0\\\"><code><span class=\\\"line\\\"><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">import</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\"> { createWalletClient, parseAbi } </span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">from</span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\"> &#x27;viem&#x27;</span></span>\\n<span class=\\\"line\\\" data-empty-line=\\\"true\\\"> </span>\\n<span class=\\\"line\\\"><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">const</span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\"> client</span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\"> =</span><span style=\\\"color:#6F42C1;--shiki-dark:#DCBDFB\\\"> createWalletClient</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">(…)</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">client.</span><span style=\\\"color:#6F42C1;--shiki-dark:#DCBDFB\\\">writeContract</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">({</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">  address: </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">&#x27;0x…&#x27;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">  abi: </span><span style=\\\"color:#6F42C1;--shiki-dark:#DCBDFB\\\">parseAbi</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">([</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">    &#x27;function transferFrom(address sender, address recipient, uint256 amount) returns (bool)&#x27;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">  ]),</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">  functionName: </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">&#x27;transferFrom&#x27;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">  args: {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">    sender: </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">&#x27;0x…&#x27;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">    recipient: </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">&#x27;0x…&#x27;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">    amount: </span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">100</span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">n</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">  },</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">})</span></span></code></pre>\\n<p>However, this only works if all the inputs are named (some compilers will strip names from inputs). If any of the inputs are unnamed, then you&#x27;ll have to use a tuple instead:</p>\\n<pre class=\\\"shiki shiki-themes github-light github-dark-dimmed\\\" style=\\\"background-color:#fff;--shiki-dark-bg:#22272e;color:#24292e;--shiki-dark:#adbac7\\\" tabindex=\\\"0\\\"><code><span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">client.</span><span style=\\\"color:#6F42C1;--shiki-dark:#DCBDFB\\\">writeContract</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">({</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">  address: </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">&#x27;0x…&#x27;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">  abi: </span><span style=\\\"color:#6F42C1;--shiki-dark:#DCBDFB\\\">parseAbi</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">([</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">    &#x27;function transferFrom(address, address, uint256) returns (bool)&#x27;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">  ]),</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">  functionName: </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">&#x27;transferFrom&#x27;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">  args: [</span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">&#x27;0x…&#x27;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">, </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">&#x27;0x…&#x27;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">, </span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">100</span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">n</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">],</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">})</span></span></code></pre>\\n<p>This can get even more complicated when a function has overloads:</p>\\n<pre class=\\\"shiki shiki-themes github-light github-dark-dimmed\\\" style=\\\"background-color:#fff;--shiki-dark-bg:#22272e;color:#24292e;--shiki-dark:#adbac7\\\" tabindex=\\\"0\\\"><code><span class=\\\"line\\\"><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">function</span><span style=\\\"color:#6F42C1;--shiki-dark:#DCBDFB\\\"> safeTransferFrom</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">(</span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">address</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">, </span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">address</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">, </span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">uint256</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">) {}</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">function</span><span style=\\\"color:#6F42C1;--shiki-dark:#DCBDFB\\\"> safeTransferFrom</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">(</span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">address</span><span style=\\\"color:#E36209;--shiki-dark:#F69D50\\\"> from</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">, </span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">address</span><span style=\\\"color:#E36209;--shiki-dark:#F69D50\\\"> to</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">, </span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">uint256</span><span style=\\\"color:#E36209;--shiki-dark:#F69D50\\\"> tokenId</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">, </span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">bytes</span><span style=\\\"color:#E36209;--shiki-dark:#F69D50\\\"> data</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">) {}</span></span></code></pre>\\n<p>In this case, the type of the overload parameters start to diverge from each other:</p>\\n<pre class=\\\"shiki shiki-themes github-light github-dark-dimmed\\\" style=\\\"background-color:#fff;--shiki-dark-bg:#22272e;color:#24292e;--shiki-dark:#adbac7\\\" tabindex=\\\"0\\\"><code><span class=\\\"line\\\"><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">type</span><span style=\\\"color:#6F42C1;--shiki-dark:#F69D50\\\"> Args</span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\"> =</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">  |</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\"> [</span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">`0x${</span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">string</span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">}`</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">, </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">`0x${</span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">string</span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">}`</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">, </span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">bigint</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">]</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">  |</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\"> {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#E36209;--shiki-dark:#F69D50\\\">      from</span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">:</span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\"> `0x${</span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">string</span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">}`</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#E36209;--shiki-dark:#F69D50\\\">      to</span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">:</span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\"> `0x${</span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">string</span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">}`</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#E36209;--shiki-dark:#F69D50\\\">      tokenId</span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">:</span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\"> bigint</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#E36209;--shiki-dark:#F69D50\\\">      data</span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">:</span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\"> string</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">    }</span></span></code></pre>\\n<p>If you want to switch between the two overloads in your code, you&#x27;ll need to completely change the type instead of just adding or removing a single positional argument from the end. (Objects also don&#x27;t enforce type-level ordering so you can put them in whatever order you want. This would also mean that viem would also need to internally validate order during runtime, adding some extra overhead.)</p>\\n<pre class=\\\"shiki shiki-themes github-light github-dark-dimmed\\\" style=\\\"background-color:#fff;--shiki-dark-bg:#22272e;color:#24292e;--shiki-dark:#adbac7\\\" tabindex=\\\"0\\\"><code><span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">client.writeContract({</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">  address: &#x27;0x…&#x27;,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">  abi: parseAbi([</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">    &#x27;function safeTransferFrom(address, address, uint256)&#x27;,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">    &#x27;function safeTransferFrom(address from, address to, uint256 tokenId, bytes data)&#x27;,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">  ]),</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">  functionName: &#x27;safeTransferFrom&#x27;,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#B31D28;--shiki-dark:#FF938A\\\">- args: [&#x27;0x…&#x27;, &#x27;0x…&#x27;, 100n],</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#22863A;--shiki-dark:#8DDB8C\\\">+ args: {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#22863A;--shiki-dark:#8DDB8C\\\">+   from: &#x27;0x…&#x27;,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#22863A;--shiki-dark:#8DDB8C\\\">+   to: &#x27;0x…&#x27;,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#22863A;--shiki-dark:#8DDB8C\\\">+   tokenId: 100n,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#22863A;--shiki-dark:#8DDB8C\\\">+   data: &#x27;0x…&#x27;,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#22863A;--shiki-dark:#8DDB8C\\\">+ },</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">})</span></span></code></pre>\\n<p>Even though overloads are an edge case, it would be sufficiently <a href=\\\"https://en.wikipedia.org/wiki/Principle_of_least_astonishment\\\">astonishing</a> to come across this behavior. So what&#x27;s the best way to represent <code>args</code>? Well, they are positional at the contract-level so it makes sense to represent them that way in viem too.</p>\\n<p>Not all is lost when it comes to developer experience though! Tuple types in TypeScript can have <a href=\\\"https://www.typescriptlang.org/play?ts=4.0.2#example/named-tuples\\\">names</a> attached to them:</p>\\n<pre class=\\\"shiki shiki-themes github-light github-dark-dimmed\\\" style=\\\"background-color:#fff;--shiki-dark-bg:#22272e;color:#24292e;--shiki-dark:#adbac7\\\" tabindex=\\\"0\\\"><code><span class=\\\"line\\\"><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">type</span><span style=\\\"color:#6F42C1;--shiki-dark:#F69D50\\\"> Args</span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\"> =</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\"> [</span><span style=\\\"color:#6F42C1;--shiki-dark:#F69D50\\\">from</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">: </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">`0x${</span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">string</span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">}`</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">, </span><span style=\\\"color:#6F42C1;--shiki-dark:#F69D50\\\">to</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">: </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">`0x${</span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">string</span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">}`</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">, </span><span style=\\\"color:#6F42C1;--shiki-dark:#F69D50\\\">tokenId</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">: </span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">bigint</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">]</span></span></code></pre>\\n<p>These names show up in your editor so you get nice developer experience when using autocomplete, etc. Unfortunately, TypeScript doesn&#x27;t support dynamic named tuples right now, but we are watching <a href=\\\"https://github.com/microsoft/TypeScript/issues/44939\\\">this issue</a> closely and once it is implemented, we will add it to viem. In the meantime, hang tight!</p>\\n\",\"id\":\"pages/docs/faq.mdx#why-are-contract-function-args-with-fully-named-inputs-represented-as-unnamed-tuple-types-instead-of-object-types\",\"isPage\":false,\"text\":\"\\nLet&#x27;s look at an example! Suppose I have the following function in my contract:\\nfunction transferFrom(address sender, address recipient, uint256 amount) returns (bool)\\nAll the inputs are named (sender, recipient, and amount) so I might be tempted to represent the parameters as the following TypeScript type:\\ntype Args = {\\n  sender: `0x${string}`;\\n  recipient: `0x${string}`;\\n  amount: bigint;\\n}\\nThis improves developer experience a bit because now I can see the names of the parameters in my editor.\\nimport { createWalletClient, parseAbi } from &#x27;viem&#x27;\\n \\nconst client = createWalletClient(…)\\nclient.writeContract({\\n  address: &#x27;0x…&#x27;,\\n  abi: parseAbi([\\n    &#x27;function transferFrom(address sender, address recipient, uint256 amount) returns (bool)&#x27;,\\n  ]),\\n  functionName: &#x27;transferFrom&#x27;,\\n  args: {\\n    sender: &#x27;0x…&#x27;,\\n    recipient: &#x27;0x…&#x27;,\\n    amount: 100n,\\n  },\\n})\\nHowever, this only works if all the inputs are named (some compilers will strip names from inputs). If any of the inputs are unnamed, then you&#x27;ll have to use a tuple instead:\\nclient.writeContract({\\n  address: &#x27;0x…&#x27;,\\n  abi: parseAbi([\\n    &#x27;function transferFrom(address, address, uint256) returns (bool)&#x27;,\\n  ]),\\n  functionName: &#x27;transferFrom&#x27;,\\n  args: [&#x27;0x…&#x27;, &#x27;0x…&#x27;, 100n],\\n})\\nThis can get even more complicated when a function has overloads:\\nfunction safeTransferFrom(address, address, uint256) {}\\nfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes data) {}\\nIn this case, the type of the overload parameters start to diverge from each other:\\ntype Args =\\n  | [`0x${string}`, `0x${string}`, bigint]\\n  | {\\n      from: `0x${string}`;\\n      to: `0x${string}`;\\n      tokenId: bigint;\\n      data: string;\\n    }\\nIf you want to switch between the two overloads in your code, you&#x27;ll need to completely change the type instead of just adding or removing a single positional argument from the end. (Objects also don&#x27;t enforce type-level ordering so you can put them in whatever order you want. This would also mean that viem would also need to internally validate order during runtime, adding some extra overhead.)\\nclient.writeContract({\\n  address: &#x27;0x…&#x27;,\\n  abi: parseAbi([\\n    &#x27;function safeTransferFrom(address, address, uint256)&#x27;,\\n    &#x27;function safeTransferFrom(address from, address to, uint256 tokenId, bytes data)&#x27;,\\n  ]),\\n  functionName: &#x27;safeTransferFrom&#x27;,\\n- args: [&#x27;0x…&#x27;, &#x27;0x…&#x27;, 100n],\\n+ args: {\\n+   from: &#x27;0x…&#x27;,\\n+   to: &#x27;0x…&#x27;,\\n+   tokenId: 100n,\\n+   data: &#x27;0x…&#x27;,\\n+ },\\n})\\nEven though overloads are an edge case, it would be sufficiently astonishing to come across this behavior. So what&#x27;s the best way to represent args? Well, they are positional at the contract-level so it makes sense to represent them that way in viem too.\\nNot all is lost when it comes to developer experience though! Tuple types in TypeScript can have names attached to them:\\ntype Args = [from: `0x${string}`, to: `0x${string}`, tokenId: bigint]\\nThese names show up in your editor so you get nice developer experience when using autocomplete, etc. Unfortunately, TypeScript doesn&#x27;t support dynamic named tuples right now, but we are watching this issue closely and once it is implemented, we will add it to viem. In the meantime, hang tight!\\n\",\"title\":\"Why are contract function args with fully-named inputs represented as unnamed tuple types instead of object types?\",\"titles\":[\"Frequently Asked Questions\"]},{\"href\":\"/docs/faq#why-is-a-contract-function-return-type-returning-an-array-instead-of-an-object\",\"html\":\"\\n<p>Suppose your ABI looks like this:</p>\\n<pre class=\\\"shiki shiki-themes github-light github-dark-dimmed\\\" style=\\\"background-color:#fff;--shiki-dark-bg:#22272e;color:#24292e;--shiki-dark:#adbac7\\\" tabindex=\\\"0\\\"><code><span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">[</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">  {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">    inputs: [],</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">    name: </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">&quot;latestRoundData&quot;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">    outputs: [</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">      { name: </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">&quot;roundId&quot;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">, type: </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">&quot;uint80&quot;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\"> },</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">      { name: </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">&quot;answer&quot;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">, type: </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">&quot;int256&quot;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\"> },</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">      { name: </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">&quot;startedAt&quot;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">, type: </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">&quot;uint256&quot;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\"> },</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">      { name: </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">&quot;updatedAt&quot;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">, type: </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">&quot;uint256&quot;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\"> },</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">      { name: </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">&quot;answeredInRound&quot;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">, type: </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">&quot;uint80&quot;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\"> },</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">    ],</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">    stateMutability: </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">&quot;view&quot;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">    type: </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">&quot;function&quot;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">  }</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">]</span></span></code></pre>\\n<p>You might be confused why the following does not return an object:</p>\\n<pre class=\\\"shiki shiki-themes github-light github-dark-dimmed\\\" style=\\\"background-color:#fff;--shiki-dark-bg:#22272e;color:#24292e;--shiki-dark:#adbac7\\\" tabindex=\\\"0\\\"><code><span class=\\\"line\\\"><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">import</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\"> { createPublicClient, parseAbi } </span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">from</span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\"> &#x27;viem&#x27;</span></span>\\n<span class=\\\"line\\\" data-empty-line=\\\"true\\\"> </span>\\n<span class=\\\"line\\\"><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">const</span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\"> client</span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\"> =</span><span style=\\\"color:#6F42C1;--shiki-dark:#DCBDFB\\\"> createPublicClient</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">(…)</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">const</span><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\"> res</span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\"> =</span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\"> await</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\"> client.</span><span style=\\\"color:#6F42C1;--shiki-dark:#DCBDFB\\\">readContract</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">({</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">  address: </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">&#x27;0x…&#x27;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">  abi: […], </span><span style=\\\"color:#6A737D;--shiki-dark:#768390\\\">// abi from above</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">  functionName: </span><span style=\\\"color:#032F62;--shiki-dark:#96D0FF\\\">&#x27;latestRoundData&#x27;</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">})</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">res</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#6A737D;--shiki-dark:#768390\\\">// ^? const res: [bigint, bigint, bigint, bigint, bigint]</span></span></code></pre>\\n<p>This is expected. <code>&quot;latestRoundData&quot;</code> <code>outputs</code> is an array of types, so you get an array of decoded values as the return type. viem only maps explicitly typed tuples as objects</p>\\n<p>Why does viem follow this approach? Here is the contract function definition for <code>latestRoundData</code> with two different return types:</p>\\n<pre class=\\\"shiki shiki-themes github-light github-dark-dimmed\\\" style=\\\"background-color:#fff;--shiki-dark-bg:#22272e;color:#24292e;--shiki-dark:#adbac7\\\" tabindex=\\\"0\\\"><code><span class=\\\"line\\\"><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">function</span><span style=\\\"color:#6F42C1;--shiki-dark:#DCBDFB\\\"> latestRoundData</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">() </span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">external</span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\"> view</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">  returns</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\"> (</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">    uint80</span><span style=\\\"color:#E36209;--shiki-dark:#F69D50\\\"> roundId</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">    int256</span><span style=\\\"color:#E36209;--shiki-dark:#F69D50\\\"> answer</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">    uint256</span><span style=\\\"color:#E36209;--shiki-dark:#F69D50\\\"> startedAt</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">    uint256</span><span style=\\\"color:#E36209;--shiki-dark:#F69D50\\\"> updatedAt</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">    uint80</span><span style=\\\"color:#E36209;--shiki-dark:#F69D50\\\"> answeredInRound</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">  );</span></span>\\n<span class=\\\"line\\\" data-empty-line=\\\"true\\\"> </span>\\n<span class=\\\"line\\\"><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">struct</span><span style=\\\"color:#6F42C1;--shiki-dark:#F69D50\\\"> Data</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\"> {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">  uint80</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\"> roundId;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">  uint256</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\"> answer;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">  uint256</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\"> startedAt;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">  uint256</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\"> updatedAt;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#005CC5;--shiki-dark:#6CB6FF\\\">  uint80</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\"> answeredInRound</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">}</span></span>\\n<span class=\\\"line\\\" data-empty-line=\\\"true\\\"> </span>\\n<span class=\\\"line\\\"><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">function</span><span style=\\\"color:#6F42C1;--shiki-dark:#DCBDFB\\\"> latestRoundData</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">() </span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">external</span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\"> view</span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\"> returns</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\"> (</span><span style=\\\"color:#D73A49;--shiki-dark:#F47067\\\">Data</span><span style=\\\"color:#E36209;--shiki-dark:#F69D50\\\"> data</span><span style=\\\"color:#24292E;--shiki-dark:#ADBAC7\\\">);</span></span></code></pre>\\n<p>The first function returns a set of five items, so viem maps it to an array. The reason why we don&#x27;t convert it to an object is because things get ambiguous when we come to decode structs. How do you determine the difference between a &quot;return&quot; tuple (first function) and a &quot;struct&quot; tuple (second function).</p>\\n<p>Another reason is that folks might expect it to be an array (because it is a set of return items). Other libraries, like ethers, mitigate this by returning a hybrid Array/Object type, but that kind of type is not serializable in JavaScript, and viem prefers to not try and &quot;hack&quot; JavaScript types.</p>\\n\",\"id\":\"pages/docs/faq.mdx#why-is-a-contract-function-return-type-returning-an-array-instead-of-an-object\",\"isPage\":false,\"text\":\"\\nSuppose your ABI looks like this:\\n[\\n  {\\n    inputs: [],\\n    name: &quot;latestRoundData&quot;,\\n    outputs: [\\n      { name: &quot;roundId&quot;, type: &quot;uint80&quot; },\\n      { name: &quot;answer&quot;, type: &quot;int256&quot; },\\n      { name: &quot;startedAt&quot;, type: &quot;uint256&quot; },\\n      { name: &quot;updatedAt&quot;, type: &quot;uint256&quot; },\\n      { name: &quot;answeredInRound&quot;, type: &quot;uint80&quot; },\\n    ],\\n    stateMutability: &quot;view&quot;,\\n    type: &quot;function&quot;,\\n  }\\n]\\nYou might be confused why the following does not return an object:\\nimport { createPublicClient, parseAbi } from &#x27;viem&#x27;\\n \\nconst client = createPublicClient(…)\\nconst res = await client.readContract({\\n  address: &#x27;0x…&#x27;,\\n  abi: […], // abi from above\\n  functionName: &#x27;latestRoundData&#x27;,\\n})\\nres\\n// ^? const res: [bigint, bigint, bigint, bigint, bigint]\\nThis is expected. &quot;latestRoundData&quot; outputs is an array of types, so you get an array of decoded values as the return type. viem only maps explicitly typed tuples as objects\\nWhy does viem follow this approach? Here is the contract function definition for latestRoundData with two different return types:\\nfunction latestRoundData() external view\\n  returns (\\n    uint80 roundId,\\n    int256 answer,\\n    uint256 startedAt,\\n    uint256 updatedAt,\\n    uint80 answeredInRound\\n  );\\n \\nstruct Data {\\n  uint80 roundId;\\n  uint256 answer;\\n  uint256 startedAt;\\n  uint256 updatedAt;\\n  uint80 answeredInRound\\n}\\n \\nfunction latestRoundData() external view returns (Data data);\\nThe first function returns a set of five items, so viem maps it to an array. The reason why we don&#x27;t convert it to an object is because things get ambiguous when we come to decode structs. How do you determine the difference between a &quot;return&quot; tuple (first function) and a &quot;struct&quot; tuple (second function).\\nAnother reason is that folks might expect it to be an array (because it is a set of return items). Other libraries, like ethers, mitigate this by returning a hybrid Array/Object type, but that kind of type is not serializable in JavaScript, and viem prefers to not try and &quot;hack&quot; JavaScript types.\\n\",\"title\":\"Why is a contract function return type returning an array instead of an object?\",\"titles\":[\"Frequently Asked Questions\"]},{\"href\":\"/docs/faq#why-doesnt-wallet-client-support-public-actions\",\"html\":\"\\n<p>Wallet Client doesn&#x27;t support public actions because wallet providers (Injected <code>window.ethereum</code>, WalletConnect v2, etc.) may not provide a large majority of &quot;node&quot;/&quot;public&quot; RPC methods like <code>eth_call</code>, <code>eth_newFilter</code>, <code>eth_getLogs</code>, etc. This is because these methods are not required for a wallet provider to function properly. For example, a wallet provider may only support <code>eth_sendTransaction</code> and <code>eth_sign</code> and nothing else.</p>\",\"id\":\"pages/docs/faq.mdx#why-doesnt-wallet-client-support-public-actions\",\"isPage\":false,\"text\":\"\\nWallet Client doesn&#x27;t support public actions because wallet providers (Injected window.ethereum, WalletConnect v2, etc.) may not provide a large majority of &quot;node&quot;/&quot;public&quot; RPC methods like eth_call, eth_newFilter, eth_getLogs, etc. This is because these methods are not required for a wallet provider to function properly. For example, a wallet provider may only support eth_sendTransaction and eth_sign and nothing else.\",\"title\":\"Why doesn&#x27;t Wallet Client support public actions?\",\"titles\":[\"Frequently Asked Questions\"]}]}}"
