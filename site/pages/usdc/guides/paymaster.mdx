# Gasless USDC Transfers with Circle Paymaster

## Overview

:::info
This guide is maintained by [Circle](https://www.circle.com).
:::

In this guide, we'll show how to send USDC on the Arbitrum Sepolia testnet **without needing any ETH for gas**, using [Circle's Paymaster service](https://developers.circle.com/stablecoins/paymaster-overview) with Viem's Account Abstraction.

We'll use an Account Abstraction (ERC-4337) smart account (via EIP-7702) to perform a USDC transfer. The Circle Paymaster will sponsor the gas in exchange for a small USDC fee, authorized by our signed permit.

By the end of this tutorial, you'll know how to:

* Set up a Viem client and a **Smart Account** on Arbitrum Sepolia
* **Check the USDC balance** for the smart account
* Create an **EIP-2612 permit signature** authorizing the Paymaster to spend USDC for gas fees
* Configure a **Paymaster and Bundler** (using Pimlico's bundler) to handle gas payment in USDC
* **Send a User Operation** that transfers USDC to a recipient, with gas fees paid in USDC via the Paymaster
* Run the script and confirm the transfer succeeded **without using any ETH** for gas

Let's get started with the environment setup, then walk through each step of the gasless USDC transfer.

::::steps

## Set up the environment and Smart Account

```ts twoslash [paymaster.ts]
import { createPublicClient, http, getContract, encodePacked, erc20Abi, hexToBigInt } from 'viem'
import { arbitrumSepolia } from 'viem/chains'
import { privateKeyToAccount } from 'viem/accounts'
import { createBundlerClient, toSimple7702SmartAccount } from 'viem/account-abstraction'

const chain = arbitrumSepolia
const usdcAddress = '0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d' // Arbitrum Sepolia USDC
const paymasterAddress = '0x3BA9A96eE3eFf3A69E2B18886AcF52027EFF8966' // Circle Paymaster v0.8
const ownerPrivateKey = '0x...' // Your private key
const recipientAddress = '0x...' // Recipient address

const client = createPublicClient({ chain, transport: http() })
const owner = privateKeyToAccount(ownerPrivateKey)
const account = await toSimple7702SmartAccount({ client, owner })
```

## Verify USDC balance (and fund if necessary)
Before sending a gasless transaction, ensure the smart account has enough USDC to cover the transfer **and** the gas fee (in USDC). We'll use Viem to read the USDC token balance of our smart account. If it's below a threshold (here we require at least **1 USDC**), the script will prompt you to fund the account via Circle's [USDC testnet faucet](https://faucet.circle.com) and then exit:

```ts [paymaster.ts]
// ...see previous step for client, usdcAddress, account
const usdc = getContract({ client, address: usdcAddress, abi: erc20Abi })
const usdcBalance = await usdc.read.balanceOf([account.address])

if (usdcBalance < 1000000n) {
  console.log(
    `Fund ${account.address} with USDC on ${client.chain.name} using https://faucet.circle.com, then run this again.`,
  )
  // Exit or return here in your script
}
```

## Create an EIP-2612 Permit for the Paymaster

Circle's Paymaster requires a **permit signature** from the user to authorize it to spend USDC for gas. We'll use the EIP-2612 permit standard (supported by USDC) to allow the Paymaster contract to pull a certain amount of USDC from our account to cover gas fees.

```ts [permit.ts]
import { maxUint256, erc20Abi, parseErc6492Signature, getContract } from 'viem'

export const eip2612Abi = [
  ...erc20Abi,
  {
    inputs: [
      {
        internalType: 'address',
        name: 'owner',
        type: 'address',
      },
    ],
    stateMutability: 'view',
    type: 'function',
    name: 'nonces',
    outputs: [
      {
        internalType: 'uint256',
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    inputs: [],
    name: 'version',
    outputs: [{ internalType: 'string', name: '', type: 'string' }],
    stateMutability: 'view',
    type: 'function',
  },
]

export async function eip2612Permit({
  token,
  chain,
  ownerAddress,
  spenderAddress,
  value,
}: {
  token: any,
  chain: any,
  ownerAddress: string,
  spenderAddress: string,
  value: bigint,
}) {
  return {
    types: {
      Permit: [
        { name: 'owner', type: 'address' },
        { name: 'spender', type: 'address' },
        { name: 'value', type: 'uint256' },
        { name: 'nonce', type: 'uint256' },
        { name: 'deadline', type: 'uint256' },
      ],
    },
    primaryType: 'Permit',
    domain: {
      name: await token.read.name(),
      version: await token.read.version(),
      chainId: chain.id,
      verifyingContract: token.address,
    },
    message: {
      owner: ownerAddress,
      spender: spenderAddress,
      value,
      nonce: await token.read.nonces([ownerAddress]),
      deadline: maxUint256,
    },
  }
}

export async function signPermit({
  tokenAddress,
  client,
  account,
  spenderAddress,
  permitAmount,
}: {
  tokenAddress: string,
  client: any,
  account: any,
  spenderAddress: string,
  permitAmount: bigint,
}) {
  const token = getContract({
    client,
    address: tokenAddress,
    abi: eip2612Abi,
  })
  const permitData = await eip2612Permit({
    token,
    chain: client.chain,
    ownerAddress: account.address,
    spenderAddress,
    value: permitAmount,
  })

  const wrappedPermitSignature = await account.signTypedData(permitData)

  const isValid = await client.verifyTypedData({
    ...permitData,
    address: account.address,
    signature: wrappedPermitSignature,
  })

  if (!isValid) {
    throw new Error(
      `Invalid permit signature for ${account.address}: ${wrappedPermitSignature}`,
    )
  }

  const { signature } = parseErc6492Signature(wrappedPermitSignature)
  return signature
}
```

## Set up the Paymaster with permit data
Now we configure the Paymaster for our User Operation using the permit we just prepared. Viem's account abstraction allows us to provide a custom **Paymaster** object with a getPaymasterData method. The bundler will call this method to attach the necessary paymaster info to our User Operation. In this method, we'll generate the permit signature on the fly and pack it into the required format:

```ts [paymaster.ts]
// ...see previous steps for imports and setup
const paymaster = {
  async getPaymasterData(parameters) {
    const permitAmount = 10000000n // 10 USDC in base units
    const permitSignature = await signPermit({
      tokenAddress: usdcAddress,
      account,
      client,
      spenderAddress: paymasterAddress,
      permitAmount: permitAmount,
    })

    const paymasterData = encodePacked(
      ['uint8', 'address', 'uint256', 'bytes'],
      [0, usdcAddress, permitAmount, permitSignature],
    )

    return {
      paymaster: paymasterAddress,
      paymasterData,
      paymasterVerificationGasLimit: 200000n,
      paymasterPostOpGasLimit: 15000n,
      isFinal: true,
    }
  },
}
```

## Initialize the Bundler client with Paymaster support
Next, set up the bundler client that will send our User Operation through a bundler service. We'll use **Pimlico's public bundler** for Arbitrum Sepolia. We configure the bundler client with our account, the paymaster, and the bundler's RPC endpoint:

```ts [paymaster.ts]
// ...see previous steps for imports and setup
const bundlerClient = createBundlerClient({
  account,
  client,
  paymaster,
  userOperation: {
    estimateFeesPerGas: async ({ account, bundlerClient, userOperation }) => {
      const { standard: fees } = await bundlerClient.request({
        method: 'pimlico_getUserOperationGasPrice',
      })
      const maxFeePerGas = hexToBigInt(fees.maxFeePerGas)
      const maxPriorityFeePerGas = hexToBigInt(fees.maxPriorityFeePerGas)
      return { maxFeePerGas, maxPriorityFeePerGas }
    },
  },
  transport: http(`https://public.pimlico.io/v2/${client.chain.id}/rpc`),
})
```

## Sign and send the User Operation (USDC transfer)
Finally, we create the User Operation to transfer USDC from our smart account to the recipient, and send it via the bundler. There are two parts here: **signing the smart account authorization** and **sending the User Operation** with the USDC transfer call.

```ts [paymaster.ts]
// ...see previous steps for owner, chain, client, account, bundlerClient, usdc, recipientAddress setup
const authorization = await owner.signAuthorization({
  chainId: chain.id,
  nonce: await client.getTransactionCount({ address: owner.address }),
  contractAddress: account.authorization.address,
})

const hash = await bundlerClient.sendUserOperation({
  account,
  calls: [
    {
      to: usdc.address,
      abi: usdc.abi,
      functionName: 'transfer',
      args: [recipientAddress, 10000000n], // 10 USDC in base units
    },
  ],
  authorization: authorization,
})
console.log('UserOperation hash', hash)

const receipt = await bundlerClient.waitForUserOperationReceipt({ hash })
console.log('Transaction hash', receipt.receipt.transactionHash)
```

## Run the script and verify the gasless transfer

Now it's time to run the script and see it all in action. Make sure you've installed the required packages (viem for the web3 interactions), and that your addresses and keys are set up in the code.

When you run it, the script will first check the USDC balance:

* If your USDC balance is too low, it will print a funding message (with a link to the faucet) and exit. Fund your smart account with some testnet USDC and rerun the script.  
* If you have sufficient USDC, the script will proceed to create the User Operation. You'll see a **UserOperation hash** logged, and then a **Transaction hash** once the operation is mined.

**Congratulations!** You've successfully sent a USDC transfer on Arbitrum Sepolia without using any ETH for gas.

::::

## Next Steps

Now that you have this working, it's time to learn about Circle's Modular wallets. 