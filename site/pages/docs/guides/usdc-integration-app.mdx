# Integrating USDC into Your Application

## Overview

This guide walks you through how to integrate **USDC** into your application using [Viem](https://viem.sh).

We'll demonstrate how to interact with the USDC token contract to enable key functionality such as reading balances, transferring funds, approving third-party spenders, monitoring transfer events, and optimizing contract reads.

You'll be using Viem's publicClient to read blockchain state and walletClient to sign and send transactions. 

We'll be working on the **Sepolia testnet**, but the steps apply to any USDC-supported EVM-compatible network.

By the end of this guide, you'll know how to:

* Set up Viem clients and securely manage accounts  
* Read and display USDC balances  
* Send USDC between wallets  
* Approve contracts (e.g., Uniswap) to spend USDC on your behalf  
* Monitor on-chain Transfer events in real-time  
* Optimize data loading with batched readContract calls

Each step is self-contained and modular — designed to be easily copied into your own project, whether you're building a wallet, a dashboard, a DeFi tool, or anything else powered by stable digital dollars.

Let's get started.

---

## Steps

### 1. Set up Viem Clients and Wallet

In this step, we'll configure a **public client** for reading blockchain data, and a **wallet client** for signing and sending transactions with USDC. You'll also set up your account using a private key.

We'll be using the Sepolia testnet, but you can easily swap this for any EVM-compatible chain.

```ts
// config.ts
import { createPublicClient, createWalletClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { sepolia } from 'viem/chains'

// Your wallet (EOA) from private key
export const account = privateKeyToAccount(process.env.PRIVATE_KEY)

export const publicClient = createPublicClient({
  chain: sepolia,
  transport: http(),
})

export const walletClient = createWalletClient({
  account,
  chain: sepolia,
  transport: http(),
})
```

We recommend storing your PRIVATE_KEY securely in a .env file, and never hard-coding it in production.

### 2. Initialize the USDC Contract

Now we'll define the **USDC token contract** by providing its address and ABI. This allows us to interact with functions like balanceOf, transfer, and approve.

You can use any USDC address from [Circle's official registry](https://developers.circle.com/stablecoins/usdc-contract-addresses), but for this guide, we're using the Sepolia testnet version.

```ts
// contract.ts
export const usdcAddress = '0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238'

export const usdcAbi = [
  {
    name: 'balanceOf',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ name: 'account', type: 'address' }],
    outputs: [{ name: '', type: 'uint256' }],
  },
  {
    name: 'transfer',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [
      { name: 'to', type: 'address' },
      { name: 'amount', type: 'uint256' }
    ],
    outputs: [{ name: '', type: 'bool' }],
  },
  {
    name: 'approve',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [
      { name: 'spender', type: 'address' },
      { name: 'amount', type: 'uint256' }
    ],
    outputs: [{ name: '', type: 'bool' }],
  },
  {
    name: 'allowance',
    type: 'function',
    stateMutability: 'view',
    inputs: [
      { name: 'owner', type: 'address' },
      { name: 'spender', type: 'address' }
    ],
    outputs: [{ name: '', type: 'uint256' }],
  },
  {
    name: 'Transfer',
    type: 'event',
    inputs: [
      { name: 'from', type: 'address', indexed: true },
      { name: 'to', type: 'address', indexed: true },
      { name: 'value', type: 'uint256', indexed: false },
    ],
  }
]
```

### 3. Check a Wallet's USDC Balance

Let's check the USDC balance of your account. This is useful for verifying holdings before transfers, or displaying token balances in a wallet UI.

```ts
// example.ts
import { formatUnits } from 'viem'
import { publicClient, account } from './config'
import { usdcAddress, usdcAbi } from './contract'

const balance = await publicClient.readContract({
  address: usdcAddress,
  abi: usdcAbi,
  functionName: 'balanceOf',
  args: [account.address],
})

console.log(`Your USDC balance: ${formatUnits(balance, 6)} USDC`)
```

Note: USDC uses 6 decimals — unlike ETH which uses 18. Always remember to format your values accordingly.

### 4. Transfer USDC

Now we'll transfer USDC from your wallet to another address. This is the most common action in USDC-based apps — whether it's sending payments, tipping, or moving funds between accounts.

```ts
// example.ts
import { parseUnits } from 'viem'
import { walletClient } from './config'
import { usdcAddress, usdcAbi } from './contract'

const hash = await walletClient.writeContract({
  address: usdcAddress,
  abi: usdcAbi,
  functionName: 'transfer',
  args: [
    '0xRecipientAddressHere',
    parseUnits('100', 6), // 100 USDC
  ],
})

console.log(`Sent 100 USDC. Tx Hash: ${hash}`)
```

### 5. Approve a Contract to Spend USDC

To interact with DeFi protocols like Uniswap, Compound, or payment processors, you'll often need to **approve a contract** to spend tokens on your behalf.

In this step, we'll approve the Uniswap Router to spend up to 1000 USDC from your wallet.

```ts
// example.ts
const hash = await walletClient.writeContract({
  address: usdcAddress,
  abi: usdcAbi,
  functionName: 'approve',
  args: [
    '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D',
    parseUnits('1000', 6),
  ],
})

console.log(`Approved 1000 USDC for Uniswap. Tx Hash: ${hash}`)
```

### 6. Check the Allowance for a Spender

Once you've approved a spender (like Uniswap), you may want to verify how much USDC they're allowed to use.

Let's fetch the allowance for the Uniswap Router.

```ts
// example.ts
import { account } from './config'

const allowance = await publicClient.readContract({
  address: usdcAddress,
  abi: usdcAbi,
  functionName: 'allowance',
  args: [
    account.address,
    '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D',
  ],
})

console.log(`Remaining allowance: ${formatUnits(allowance, 6)} USDC`)
```

### 7. Watch for USDC Transfers

Let's subscribe to real-time "Transfer events" emitted by the USDC contract. This is useful for building wallet UIs, dashboards, or backend listeners.

```ts
// example.ts
const unwatch = publicClient.watchContractEvent({
  address: usdcAddress,
  abi: usdcAbi,
  eventName: 'Transfer',
  onLogs: (logs) => {
    logs.forEach((log) => {
      const { from, to, value } = log.args
      console.log(`Transfer: ${from} → ${to} (${formatUnits(value, 6)} USDC)`)
    })
  },
})

// Optional: stop watching after 1 minute
setTimeout(() => unwatch(), 60_000)
```

### 8. Perform Multiple Reads at Once (Optional)

Finally, let's optimize by fetching multiple contract values in parallel — including balance, symbol, and decimals — using Promise.all.

This is great for loading data-rich dashboards.

```ts
// example.ts
const [balance, symbol, decimals] = await Promise.all([
  publicClient.readContract({ address: usdcAddress, abi: usdcAbi, functionName: 'balanceOf', args: [account.address] }),
  publicClient.readContract({ address: usdcAddress, abi: usdcAbi, functionName: 'symbol' }),
  publicClient.readContract({ address: usdcAddress, abi: usdcAbi, functionName: 'decimals' }),
])

console.log(`You have ${formatUnits(balance, Number(decimals))} ${symbol}`)
```

---

## Next Steps

* Add support for multiple chains using Circle's cross chain transfer protocol. 