import type { Address } from 'abitype'
import * as SignatureErc6492 from 'ox/erc6492/SignatureErc6492'
import * as SignatureErc8010 from 'ox/erc8010/SignatureErc8010'

import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import {
  erc1271Abi,
  erc6492SignatureValidatorAbi,
  multicall3Abi,
} from '../../constants/abis.js'
import {
  erc6492SignatureValidatorByteCode,
  multicall3Bytecode,
} from '../../constants/contracts.js'
import { CallExecutionError } from '../../errors/contract.js'
import type { InvalidHexBooleanError } from '../../errors/encoding.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'
import type { ByteArray, Hex, Signature } from '../../types/misc.js'
import type { OneOf } from '../../types/utils.js'
import {
  type EncodeDeployDataErrorType,
  encodeDeployData,
} from '../../utils/abi/encodeDeployData.js'
import { getAddress } from '../../utils/address/getAddress.js'
import { isAddressEqual } from '../../utils/address/isAddressEqual.js'
import { type IsHexErrorType, isHex } from '../../utils/data/isHex.js'
import {
  bytesToHex,
  numberToHex,
  type ToHexErrorType,
} from '../../utils/encoding/toHex.js'
import { getAction } from '../../utils/getAction.js'
import { concatHex, encodeFunctionData, hexToBool } from '../../utils/index.js'
import { recoverAddress } from '../../utils/signature/recoverAddress.js'
import { serializeSignature } from '../../utils/signature/serializeSignature.js'
import { type CallErrorType, type CallParameters, call } from './call.js'
import { getCode } from './getCode.js'
import { readContract } from './readContract.js'

export type VerifyHashParameters = Pick<
  CallParameters,
  'blockNumber' | 'blockTag'
> & {
  /** The address that signed the original message. */
  address: Address
  /** The address of the ERC-6492 signature verifier contract. */
  erc6492VerifierAddress?: Address | undefined
  /** The hash to be verified. */
  hash: Hex
  /** The signature that was generated by signing the message with the address's private key. */
  signature: Hex | ByteArray | Signature
  /** @deprecated use `erc6492VerifierAddress` instead. */
  universalSignatureVerifierAddress?: Address | undefined
} & OneOf<{ factory: Address; factoryData: Hex } | {}>

export type VerifyHashReturnType = boolean

export type VerifyHashErrorType =
  | CallErrorType
  | IsHexErrorType
  | ToHexErrorType
  | InvalidHexBooleanError
  | EncodeDeployDataErrorType
  | ErrorType

/**
 * Verifies a message hash onchain using ERC-6492.
 *
 * @param client - Client to use.
 * @param parameters - {@link VerifyHashParameters}
 * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}
 */
export async function verifyHash<chain extends Chain | undefined>(
  client: Client<Transport, chain>,
  parameters: VerifyHashParameters,
): Promise<VerifyHashReturnType> {
  const {
    address,
    hash,
    erc6492VerifierAddress:
      verifierAddress = parameters.universalSignatureVerifierAddress ??
      client.chain?.contracts?.erc6492Verifier?.address,
  } = parameters

  const signature = (() => {
    const signature = parameters.signature
    if (isHex(signature)) return signature
    if (typeof signature === 'object' && 'r' in signature && 's' in signature)
      return serializeSignature(signature)
    return bytesToHex(signature)
  })()

  try {
    if (SignatureErc8010.validate(signature))
      return await verifyErc8010(client, {
        ...parameters,
        signature,
      })
    return await verifyErc6492(client, {
      ...parameters,
      verifierAddress,
      signature,
    })
  } catch (error) {
    // Fallback attempt to verify the signature via ECDSA recovery.
    try {
      const verified = isAddressEqual(
        getAddress(address),
        await recoverAddress({ hash, signature }),
      )
      if (verified) return true
    } catch {}

    if (error instanceof CallExecutionError) {
      // if the execution fails, the signature was not valid and an internal method inside of the validator reverted
      // this can happen for many reasons, for example if signer can not be recovered from the signature
      // or if the signature has no valid format
      return false
    }

    throw error
  }
}

/** @internal */
// biome-ignore lint/correctness/noUnusedVariables: _
async function verifyErc8010(
  client: Client,
  parameters: verifyErc8010.Parameters,
) {
  const { address, blockNumber, blockTag, hash } = parameters

  const {
    authorization,
    data: initData,
    signature,
  } = SignatureErc8010.unwrap(parameters.signature)

  // Check if already delegated
  const code = await getCode(client, {
    address,
    blockNumber,
    blockTag,
  } as never)

  // If already delegated, perform standard ERC-1271 verification.
  if (code === concatHex(['0xef0100', authorization.address]))
    return await verifyErc1271(client, {
      address,
      blockNumber,
      blockTag,
      hash,
      signature: parameters.signature,
    })

  // Deployless verification.
  const results = await readContract(client, {
    authorizationList: [
      {
        address: authorization.address,
        chainId: Number(authorization.chainId),
        nonce: Number(authorization.nonce),
        r: numberToHex(authorization.r, { size: 32 }),
        s: numberToHex(authorization.s, { size: 32 }),
        yParity: authorization.yParity,
      },
    ],
    abi: multicall3Abi,
    blockNumber,
    blockTag: 'pending',
    code: multicall3Bytecode,
    functionName: 'aggregate3',
    args: [
      [
        ...(initData
          ? [
              {
                allowFailure: false,
                target: address,
                callData: initData,
              },
            ]
          : []),
        {
          allowFailure: false,
          target: address,
          callData: encodeFunctionData({
            abi: erc1271Abi,
            functionName: 'isValidSignature',
            args: [hash, signature],
          }),
        },
      ],
    ],
  })

  const data = results[results.length - 1]?.returnData

  if (data?.startsWith('0x1626ba7e')) return true
  throw new Error()
}

export namespace verifyErc8010 {
  export type Parameters = Pick<CallParameters, 'blockNumber' | 'blockTag'> & {
    /** The address that signed the original message. */
    address: Address
    /** The hash to be verified. */
    hash: Hex
    /** The signature that was generated by signing the message with the address's private key. */
    signature: Hex
  }
}

/** @internal */
// biome-ignore lint/correctness/noUnusedVariables: _
async function verifyErc6492(
  client: Client,
  parameters: verifyErc6492.Parameters,
) {
  const {
    address,
    factory,
    factoryData,
    hash,
    signature,
    verifierAddress,
    ...rest
  } = parameters

  const wrappedSignature = await (async () => {
    // If no `factory` or `factoryData` is provided, it is assumed that the
    // address is not a Smart Account, or the Smart Account is already deployed.
    if (!factory && !factoryData) return signature

    // If the signature is already wrapped, return the signature.
    if (SignatureErc6492.validate(signature)) return signature

    // If the Smart Account is not deployed, wrap the signature with a 6492 wrapper
    // to perform counterfactual validation.
    return SignatureErc6492.wrap({
      data: factoryData!,
      signature,
      to: factory!,
    })
  })()

  const args = verifierAddress
    ? ({
        to: verifierAddress,
        data: encodeFunctionData({
          abi: erc6492SignatureValidatorAbi,
          functionName: 'isValidSig',
          args: [address, hash, wrappedSignature],
        }),
        ...rest,
      } as unknown as CallParameters)
    : ({
        data: encodeDeployData({
          abi: erc6492SignatureValidatorAbi,
          args: [address, hash, wrappedSignature],
          bytecode: erc6492SignatureValidatorByteCode,
        }),
        ...rest,
      } as unknown as CallParameters)

  const { data } = await getAction(client, call, 'call')(args)

  if (hexToBool(data ?? '0x0')) return true
  throw new Error()
}

export namespace verifyErc6492 {
  export type Parameters = Pick<CallParameters, 'blockNumber' | 'blockTag'> & {
    /** The address that signed the original message. */
    address: Address
    /** The hash to be verified. */
    hash: Hex
    /** The signature that was generated by signing the message with the address's private key. */
    signature: Hex
    /** The address of the ERC-6492 signature verifier contract. */
    verifierAddress?: Address | undefined
  } & OneOf<{ factory: Address; factoryData: Hex } | {}>
}

/** @internal */
export async function verifyErc1271(
  client: Client,
  parameters: verifyErc1271.Parameters,
) {
  const { address, blockNumber, blockTag, hash, signature } = parameters

  const result = await readContract(client, {
    address,
    abi: erc1271Abi,
    args: [hash, signature],
    blockNumber,
    blockTag,
    functionName: 'isValidSignature',
  })

  if (result.startsWith('0x1626ba7e')) return true
  throw new Error()
}

export namespace verifyErc1271 {
  export type Parameters = Pick<CallParameters, 'blockNumber' | 'blockTag'> & {
    /** The address that signed the original message. */
    address: Address
    /** The hash to be verified. */
    hash: Hex
    /** The signature that was generated by signing the message with the address's private key. */
    signature: Hex
  }
}
